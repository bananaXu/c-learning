Volatile
	(1) volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，
		而是重新从内存中读取。
	(2) Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，
		一定会被执行。
	(3) Volatile关键词的第三个特性：”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。
	(4) C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部
		都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力。
		针对这个多线程的应用，真正正确的做法，是构建一个happens-before语义。
static
	控制变量的存储方式和可见性。
	(1) 修饰局部变量
		一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，
		其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有
		改变，其仍然是一个局部变量，作用域仅限于该语句块。
	(2) 修饰全局变量
		对于一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问(只需用extern进行声明即可)。用static对全局变量进行修饰改变了
		其作用域的范围，由原来的整个工程可见变为本源文件可见。
	(3) 修饰函数
		用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。
	(4) C++中的static
		如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类
		以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。
const的含义及实现机制
	const名叫常量限定符，用来限定特定变量，以通知编译器该变量是不可修改的。习惯性的使用const，可以避免在函数中对某些不应修改的变量造成可能的改动。
	(1) const修饰基本数据类型
		1.const修饰一般常量及数组
		基本数据类型，修饰符const可以用在类型说明符前，也可以用在类型说明符后，其结果是一样的。在使用这些常量的时候，只要不改变这些常量的值便好。 
		2.const修饰指针变量*及引用变量&  
		如果const位于星号*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
		如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量。
	(2) const应用到函数中,  
		1.作为参数的const修饰符
		调用函数的时候，用相应的变量初始化const常量，则在函数体中，按照const所修饰的部分进行常量化,保护了原对象的属性。
		[注意]：参数const通常用于参数为指针或引用的情况; 
		2.作为函数返回值的const修饰符
		声明了返回值后，const按照"修饰原则"进行修饰，起到相应的保护作用。
	(3) const在类中的用法
		不能在类声明中初始化const数据成员。正确的使用const实现方法为：const数据成员的初始化只能在类构造函数的初始化表中进行
		类中的成员函数：A fun4()const; 其意义上是不能修改所在类的的任何变量。
	(4) const修饰类对象，定义常量对象 
		常量对象只能调用常量函数，别的成员函数都不能调用。
extern
	(1) 在C语言中，修饰符extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。
	(2) 注意extern声明的位置对其作用域也有关系，如果是在main函数中进行声明的，则只能在main函数中调用，在其它函数中不能调用。其实要调用其它文件中的函数
		和变量，只需把该文件用#include包含进来即可，为啥要用extern？因为用extern会加速程序的编译过程，这样能节省时间。
	(3) 在C++中extern还有另外一种作用，用于指示C或者C＋＋函数的调用规范。比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这
		是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
宏定义和展开、内联函数区别
	(1) 内联函数是代码被插入到调用者代码处的函数。如同 #define 宏，内联函数通过避免被调用的开销来提高执行效率，尤其是它能够通过调用（“过程化集成”）被编
		译器优化。 宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。	内联函数和宏很类似，而区别在于，宏是由
		预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函
		数的参数压栈，减少了调用的开销。
	(2) 宏是预编译器的输入，然后宏展开之后的结果会送去编译器做语法分析。宏与函数等处于不同的级别，操作不同的实体。宏操作的是 token, 可以进行 token的替换
		和连接等操作，在语法分析之前起作用。而函数是语言中的概念，会在语法树中创建对应的实体，内联只是函数的一个属性。
	(3) 对于问题：有了函数要它们何用？答案是：一：函数并不能完全替代宏，有些宏可以在当前作用域生成一些变量，函数做不到。二：内联函数只是函数的一种，内联
		是给编译器的提示，告诉它最好把这个函数在被调用处展开，省掉一个函数调用的开销（压栈，跳转，返回）
	(4) 内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，
		内联函数就和普通函数执行效率一样
	(5) 内联函数必须是和函数体申明在一起，才有效。
STL六大组件
	1、容器		各种数据结构，如序列容器：vector、list、deque，关联式容器：set、map、multiset、multimap
	2、算法		常用算法，如sort、search、copy、erase，任何一个算法都要指定一个迭代器区间，[first, last)
	3、迭代器	容器与算法之间的胶合剂，是所谓的“泛型指针”,共有5种类型，以及其他衍生变化。从实现角度，迭代器是将operator*、operator->、operator++、
				operator--等指针相关操作进行重载的class template，所有的容器都有自己的专属迭代器，只有容器本身知道如何遍历。原生指针也是一种迭代器。
	4、仿函数	行为类似函数，可作为算法的某种策略。从实现角度，仿函数是一种重载了operator()的class或class template。一般的函数指针也可视为狭义仿函数
	5、配接器	一种来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue和stack，看似容器，其实只能算容器配接器，因为他们底部完全借助deque，所
				有操作都由底层的deque供应，改变functors接口者，称为function adapter，改变container接口者，称为container adapter，改变iterator接口者，
				称为iterator adapter。
	6、配置器	负责空间配置与管理。从实现角度来看，配置器是实现了动态空间配置、空间管理、空间释放的class template。
虚函数的作用和实现原理
	c++多态分为静态多态(编译时多态)和动态多态(运行时多态)两大类。静态多态通过函数重载、模板来实现。动态多态就是通过虚函数来实现。
	虚函数实现原理: 虚函数表、虚函数指针等。
	虚函数作用：调用一个虚函数时，被执行的代码必须和调用函数的对象的动态类型一致。编译器需要做的就是如何高效的实现提供这种特性。不同编译器实现细节不相
	同，大多数编译器通过vtbl(virtual table)和vptr(virtual table pointer)来实现的。当一个类声明了虚函数或者继承了虚函数，这个类就会有自己的vtbl，vtbl实
	际上就是一个函数指针数组，有的编译器用的是链表。vtbl数组中每个元素对应一个函数指针指向该类的一个虚函数，同时该类的每一个对象都会包含一个vptr，vptr
	指向该vtbl的地址。
	纯虚函数：纯虚函数是在基类中声明的虚函数，他在基类中没有定义，要求任何派生类都要定义自己的实现方法。virtual void funtion1()=0。
		原因：
		1、为了方便使用多态特性，我们常常需要在基类中定义虚函数
		2、很多情况下，基类本身生成对象是不合情理的。例如：动物作为基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不和情理。
		定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
	为什么需要虚析构函数？
		一般情况下，类的析构函数都是释放内存资源，而析构函数不被调用就会产生内存泄漏。只有当类作为基类时才把析构函数写成虚析构函数。
	inline, static, constructor三种函数都不能带有virtual关键字。
	虚函数的一些常见问题：
		1)	虚函数是动态绑定的，也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数。这是虚函数的基本功能，就不再解释了。 
		2) 	构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 
		3) 	析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。
		4) 	将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类，不能实例化对象。 
		5) 	纯虚函数通常没有定义体，但也完全可以拥有。
		6) 	析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。 
		7)	非纯的虚函数必须有定义体，不然是一个错误。 
		8)	派生类的override虚函数定义必须和父类完全一致。除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。
			例如，在上面的例子中，在Base中定义了 virtual Base* clone(); 在Derived中可以定义为 virtual Derived* clone()。可以看到，这种放松对于Clone模式
			是非常有用的。
		9)	用C++设计一个不能被继承的类:构造函数或析构函数为私有函数，所以该类是无法被继承的，
内存分配
	(1)	从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
	(2)	在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效
		率很高，但是分配的内存容量有限。
	(3)	从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们
		决定，使用非常灵活，但问题也最多。
linux的内存管理机制，内存寻址方式，什么叫虚拟内存，内存调页算法，任务调度算法
	1、 Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制。
	2、 内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果
		有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么
		就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，
		也要修改页表来映射文件地址。
	3、 进程和线程、进程间及线程通信方式、共享内存的使用实现原理
死锁必要条件及避免方法
	1、 资源不能共享，只能由一个进程使用
	2、 请求与保持：已经得到资源的进程可以再次申请新的资源。
	3、 不可剥夺：已经分配的资源不能从相应的进程中强制剥夺。
	4、	循环等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正在占用的资源。
		处理死锁的策略：1、忽略该问题。例如鸵鸟算法，该算法可以应用在极少发生死锁的情况下。2、检测死锁并恢复。3、仔细地对资源进行动态分配，避免死锁。
		4、破除死锁4个条件之一，来防止产生死锁。
动态链接和静态链接
	动态链接只是建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中。运行时再装入；而静态链接是把所有代码和数据都复制到本模块中，不需要库了。
常见的信号、系统如何将一个信号通知到进程
	信号机制是进程之间想互传递消息的一种方法，信号全称为软中断信号，也有人称软中断。
	进程之间可以互相通过系统调用kill发送软中断信号。
	SIGHUP 1 A 终端挂起或者控制进程终止 
	SIGINT 2 A 键盘中断（如break键被按下） 
	SIGQUIT 3 C 键盘的退出键被按下 
	SIGILL 4 C 非法指令 
	SIGABRT 6 C 由abort(3)发出的退出指令 
	SIGFPE 8 C 浮点异常 
	SIGKILL 9 AEF Kill信号 
	SIGSEGV 11 C 无效的内存引用 
	SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道 
	信号机制是异步的，当一个进程接受到一个信号时，它会立刻处理这个信号，而不会等待当前信号甚至当前一行代码运行结束。信号有几十种，分别代表着不同的意义。信号
	之间依靠它们的值来区分，但是通常在程序中使用信号的名字来表示一个信号。在Linux系统中，这些信号和以它们的名称命名的常量均定义在/usr/include/bits/signum.h
	文件中。（通常程序中不需要直接包含这个头文件，而应该包含<signal.h>。
	信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，
	软件来源还包括一些非法运算等操作。
	发送信号的主要函数有：kill()、raise()、 sigqueue()、alarm()、setitimer()以及abort()。
	进程可以通过三种方式来响应一个信号：（1）忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP；（2）捕捉信号。定义信号处理函数，当
	信号发生时，执行相应的处理函数；（3）执行缺省操作，
linux系统的各类同步机制、linux系统的各类异步机制、
	如何实现守护进程
		守护进程最重要的特性是后台运行。		
		1. 	在后台运行。
			为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，让Daemon在子进程中后台执行。
			if(pid=fork())
			exit(0); //是父进程，结束父进程，子进程继续
		2. 	脱离控制终端，登录会话和进程组
			有必要先介绍一下Linux中的进程与控制终端，登录会话和进程组之间的关系：进程属于一个进程组，进程组号（GID）就是进程组长的进程号（PID）。登录会话可以
			包含多个进程组。这些进程组共享一个控制终端。这个控制终端通常是创建进程的登录终端。控制终端，登录会话和进程组通常是从父进程继承下来的。我们的目的
			就是要摆脱它们，使之不受它们的影响。方法是在第1点的基础上，调用setsid()使进程成为会话组长：setsid();
			说明：当进程是会话组长时setsid()调用失败。但第一点已经保证进程不是会话组长。setsid()调用成功后，进程成为新的会话组长和新的进程组长，并与原来的登
			录会话和进程组脱离。由于会话过程对控制终端的独占性，进程同时与控制终端脱离。
		3. 	禁止进程重新打开控制终端
			现在，进程已经成为无终端的会话组长。但它可以重新申请打开一个控制终端。可以通过使进程不再成为会话组长来禁止进程重新打开控制终端：
			if(pid=fork()) exit(0); //结束第一子进程，第二子进程继续（第二子进程不再是会话组长）
		4. 	关闭打开的文件描述符
			进程从创建它的父进程那里继承了打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。按如下方法关闭
			它们：
			for(i=0;i 关闭打开的文件描述符close(i);>
		5. 	改变当前工作目录
			进程活动时，其工作目录所在的文件系统不能卸下。一般需要将工作目录改变到根目录。对于需要转储核心，写运行日志的进程将工作目录改变到特定目录如 /tmpchdir("/")
		6. 	重设文件创建掩模
			进程从创建它的父进程那里继承了文件创建掩模。它可能修改守护进程所创建的文件的存取位。为防止这一点，将文件创建掩模清除：umask(0);
		7. 	处理SIGCHLD信号
			处理SIGCHLD信号并不是必须的。但对于某些进程，特别是服务器进程往往在请求到来时生成子进程处理请求。如果父进程不等待子进程结束，子进程将成为僵尸
			进程(zombie)从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将 SIGCHLD信号的操作
			设为SIG_IGN
			signal(SIGCHLD,SIG_IGN);
			这样，内核在子进程结束时不会产生僵尸进程。这一点与BSD4不同，BSD4下必须显式等待子进程结束才能释放僵尸进程。
标准库函数和系统调用的区别
	1、	系统调用
		系统调用提供的函数如open, close, read, write, ioctl等，需包含头文件unistd.h。以write为例：其函数原型为 size_t write(int fd, const void *buf, size_t
		nbytes)，其操作对象为文件描述符或文件句柄fd(file descriptor)，要想写一个文件，必须先以可写权限用open系统调用打开一个文件，获得所打开文件的fd，例如
		fd=open(/"/dev/video/", O_RDWR)。fd是一个整型值，每新打开一个文件，所获得的fd为当前最大fd加1。Linux系统默认分配了3个文件描述符值：0－standard input，
		1－standard output，2－standard error。
		系统调用通常用于底层文件访问（low-level file access），例如在驱动程序中对设备文件的直接访问。
		系统调用是操作系统相关的，因此一般没有跨操作系统的可移植性。
		系统调用发生在内核空间，因此如果在用户空间的一般应用程序中使用系统调用来进行文件操作，会有用户空间到内核空间切换的开销。事实上，即使在用户空间使用库
		函数来对文件进行操作，因为文件总是存在于存储介质上，因此不管是读写操作，都是对硬件（存储器）的操作，都必然会引起系统调用。也就是说，库函数对文件的操
		作实际上是通过系统调用来实现的。例如C库函数fwrite()就是通过write()系统调用来实现的。
		这样的话，使用库函数也有系统调用的开销，为什么不直接使用系统调用呢？这是因为，读写文件通常是大量的数据（这种大量是相对于底层驱动的系统调用所实现的数
		据操作单位而言），这时，使用库函数就可以大大减少系统调用的次数。这一结果又缘于缓冲区技术。在用户空间和内核空间，对文件操作都使用了缓冲区，例如用fwrite
		写文件，都是先将内容写到用户空间缓冲区，当用户空间缓冲区满或者写操作结束时，才将用户缓冲区的内容写到内核缓冲区，同样的道理，当内核缓冲区满或写结束时
		才将内核缓冲区内容写到文件对应的硬件媒介。
	2、库函数调用
		标准C库函数提供的文件操作函数如fopen, fread, fwrite, fclose,fflush, fseek等，需包含头文件stdio.h。以fwrite为例，其函数原型为size_t fwrite(const void
		*buffer,size_t size, size_t item_num, FILE *pf)，其操作对象为文件指针FILE *pf，要想写一个文件，必须先以可写权限用fopen函数打开一个文件，获得所打开文件
		的FILE结构指针pf，例如pf=fopen(/"~/proj/filename/",/"w/")。实际上，由于库函数对文件的操作最终是通过系统调用实现的，因此，每打开一个文件所获得的FILE结
		构指针都有一个内核空间的文件描述符fd与之对应。同样有相应的预定义的FILE指针：stdin－standard input，stdout－standard output，stderr－standard error。
		库函数调用通常用于应用程序中对一般文件的访问。
		库函数调用是系统无关的，因此可移植性好。
		由于库函数调用是基于C库的，因此也就不可能用于内核空间的驱动程序中对设备的操作

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		